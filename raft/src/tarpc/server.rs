use crate::server::{Endpoints, RaftServer, RpcDriver};
use crate::ServerId;
use crate::{AppendEntries, Term, VoteRequest};
use futures_new::{
    compat::{Compat, TokioDefaultSpawner},
    future::{self, Ready},
    prelude::*,
};
use log::*;
use serde::{Deserialize, Serialize};
use std::collections::BTreeMap;
use std::io;
use std::sync::{Arc, Mutex, Weak};
use tarpc::server::Handler;
use tarpc::{self, client};
use tokio::runtime::Runtime;

#[derive(Serialize, Deserialize, Debug)]
pub struct AppendResponse {
    term: Term,
    success: bool,
}

#[derive(Serialize, Deserialize, Debug)]
pub struct VoteResponse {
    term: Term,
    vote_granted: bool,
}

mod service {
    use super::*;

    tarpc::service! {
        rpc append_entries(req: AppendEntries) -> AppendResponse;
        rpc request_vote(req: VoteRequest) -> VoteResponse;
    }
}

impl service::Service for Arc<Mutex<RaftServer<TarpcDriver>>> {
    type AppendEntriesFut = Ready<AppendResponse>;

    fn append_entries(
        self,
        _: tarpc::context::Context,
        _req: AppendEntries,
    ) -> Self::AppendEntriesFut {
        future::ready(AppendResponse {
            term: 0,
            success: false,
        })
    }

    type RequestVoteFut = Ready<VoteResponse>;

    fn request_vote(self, _: tarpc::context::Context, _req: VoteRequest) -> Self::RequestVoteFut {
        future::ready(VoteResponse {
            term: 0,
            vote_granted: false,
        })
    }
}

pub struct TarpcDriver {
    //rpc_server: Option<tarpc::server::Server>,
    endpoints: Endpoints,
    clients: BTreeMap<ServerId, service::Client>,
    runtime: Arc<Mutex<Runtime>>,
}

#[allow(unused)]
impl RpcDriver for TarpcDriver {
    type LeaderState = ();

    fn new(id: ServerId, endpoints: Endpoints, runtime: Arc<Mutex<Runtime>>) -> Self {
        tarpc::init(TokioDefaultSpawner);
        TarpcDriver {
            endpoints,
            clients: Default::default(),
            runtime,
        }
    }

    fn connect_all(&mut self) {
        let mut clients = Arc::new(Mutex::new(BTreeMap::new()));

        let all = self
            .endpoints
            .iter()
            .inspect(|(id, _)| debug!("connecting to client {}", id))
            .map(|(id, endpoint)| (*id, connect_endpoint(endpoint.clone())))
            .map(|(id, conn)| {
                let clients = clients.clone();
                conn.boxed().map(move |client| match client {
                    Ok(client) => {
                        debug!("Connected to client {}", id);
                        clients.lock().unwrap().insert(id, client);
                    }
                    Err(e) => error!("Error connecting to client {}: {}", id, e),
                })
            });
        let task = future::join_all(all).map(|results| {
            dbg!(results);
            Ok(())
        });
        run_on_current_thread(task);

        debug!("Finished connect_all");
        std::mem::swap(&mut self.clients, &mut *clients.lock().unwrap());
    }

    fn create_rpc_server(&mut self, endpoint: String, raft_server: Weak<Mutex<RaftServer<Self>>>) {
        debug!("create_rpc_server");
        self.runtime.lock().unwrap().spawn(
            run(endpoint, raft_server)
                .map_err(|e| error!("Error while running server: {}", e))
                .boxed()
                .compat(),
        );
        debug!("create_rpc_server finished");
    }

    fn timeout(raft_server: &mut RaftServer<Self>) {
        raft_server.timeout();
    }
}

fn run_on_current_thread(task: impl TryFuture<Ok = (), Error = ()> + Unpin + 'static) {
    let mut runtime = tokio::runtime::current_thread::Runtime::new().unwrap();
    runtime.spawn(Compat::new(task));
    runtime.run().unwrap();
    //runtime.block_on(Compat::new(task));
}

async fn connect_endpoint(endpoint: String) -> io::Result<service::Client> {
    let addr = endpoint.parse().expect("Could not parse server address");
    let transport = await!(bincode_transport::connect(&addr))?;

    // new_stub is generated by the service! macro. Like Server, it takes a config and any
    // Transport as input, and returns a Client, also generated by the macro.
    // by the service mcro.
    let client = await!(service::new_stub(client::Config::default(), transport))?;
    Ok(client)
}

type ApplyError = ();
impl RaftServer<TarpcDriver> {
    fn timeout(&mut self) {
        self.reset_timeout();
        warn!("timeout unimplemented");
    }

    pub fn apply_one(
        &mut self,
        _entry: Vec<u8>,
    ) -> impl Future<Output = Result<Vec<u8>, ApplyError>> {
        future::ready(Ok(vec![]))
    }

    pub fn spawn<F>(&self, f: F)
    where
        F: Future<Output = Result<(), ()>> + Send + Unpin + 'static,
    {
        tokio::run(Compat::new(f));
    }
}

async fn run(
    endpoint: String,
    raft_server: Weak<Mutex<RaftServer<TarpcDriver>>>,
) -> io::Result<()> {
    let raft_server: Arc<Mutex<RaftServer<TarpcDriver>>> = raft_server.upgrade().expect("asdf");
    let transport =
        bincode_transport::listen(&endpoint.parse().unwrap()).expect("could not listen");
    let server = tarpc::server::new(tarpc::server::Config::default())
        .incoming(transport)
        .respond_with(service::serve(raft_server));

    await!(server);

    Ok(())
}
